package oracle

import (
	"database/sql"
	"fmt"
	"math"
	"regexp"
	"strconv"

	_ "github.com/godror/godror"
	"gorm.io/gorm"
	"gorm.io/gorm/callbacks"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/logger"
	"gorm.io/gorm/migrator"
	"gorm.io/gorm/schema"

	oracleCallbacks "github.com/gabrielkim13/gorm-oracle/callbacks"
	oracleClause "github.com/gabrielkim13/gorm-oracle/clause"
)

type Config struct {
	DriverName string
	DSN        string
	Conn       gorm.ConnPool
}

type Dialector struct {
	*Config
}

func Open(dsn string) gorm.Dialector {
	return &Dialector{Config: &Config{DSN: dsn}}
}

func New(config Config) gorm.Dialector {
	return &Dialector{Config: &config}
}

func (d Dialector) Name() string {
	return "oracle"
}

func (d Dialector) Initialize(db *gorm.DB) (err error) {
	// TODO: Add support for "ON CONFLICT" on `Create`, using the "MERGE" clause
	callbacks.RegisterDefaultCallbacks(db, &callbacks.Config{
		CreateClauses: []string{"INSERT", "VALUES", "RETURNING"},
	})

	d.DriverName = "godror"

	if d.Conn != nil {
		db.ConnPool = d.Conn
	} else {
		db.ConnPool, err = sql.Open(d.DriverName, d.DSN)
		if err != nil {
			return err
		}
	}

	oracleClause.RewriteClauseBuilders(db)
	if err = oracleCallbacks.RewriteCallbacks(db); err != nil {
		return
	}

	return
}

func (d Dialector) Migrator(db *gorm.DB) gorm.Migrator {
	return Migrator{
		Migrator: migrator.Migrator{
			Config: migrator.Config{
				DB:                          db,
				Dialector:                   d,
				CreateIndexAfterCreateTable: true,
			},
		},
	}
}

func (d Dialector) DataTypeOf(field *schema.Field) string {
	switch field.DataType {
	case schema.Bool:
		return "NUMBER(1)"
	case schema.Int, schema.Uint:
		return getSchemaIntAndUintType(field)
	case schema.Float:
		return getSchemaFloatType(field)
	case schema.String:
		return getSchemaStringType(field)
	case schema.Time:
		return "TIMESTAMP WITH TIME ZONE"
	case schema.Bytes:
		return "BLOB"
	default:
		return string(field.DataType)
	}
}

func (d Dialector) DefaultValueOf(_ *schema.Field) clause.Expression {
	return clause.Expr{SQL: "DEFAULT"}
}

func (d Dialector) BindVarTo(writer clause.Writer, stmt *gorm.Statement, _ interface{}) {
	_ = writer.WriteByte(':')
	_, _ = writer.WriteString(strconv.Itoa(len(stmt.Vars)))
}

func (d Dialector) QuoteTo(writer clause.Writer, s string) {
	var (
		underQuoted, selfQuoted bool
		continuousBacktick      int8
		shiftDelimiter          int8
	)

	for _, v := range []byte(s) {
		switch v {
		case '"':
			if continuousBacktick++; continuousBacktick == 2 {
				_, _ = writer.WriteString(`""`)
				continuousBacktick = 0
			}
		case '.':
			if continuousBacktick > 0 || !selfQuoted {
				shiftDelimiter = 0
				underQuoted = false
				continuousBacktick = 0
				_ = writer.WriteByte('"')
			}

			_ = writer.WriteByte(v)

			continue
		default:
			if shiftDelimiter-continuousBacktick <= 0 && !underQuoted {
				_ = writer.WriteByte('"')
				underQuoted = true

				if selfQuoted = continuousBacktick > 0; selfQuoted {
					continuousBacktick -= 1
				}
			}

			for ; continuousBacktick > 0; continuousBacktick -= 1 {
				_, _ = writer.WriteString(`""`)
			}

			_ = writer.WriteByte(v)
		}

		shiftDelimiter++
	}

	if continuousBacktick > 0 && !selfQuoted {
		_, _ = writer.WriteString(`""`)
	}

	_ = writer.WriteByte('"')
}

func (d Dialector) Explain(sql string, vars ...interface{}) string {
	var numericPlaceholder = regexp.MustCompile(`:(\d+)`)

	avars := make([]interface{}, 0, len(vars))

	for _, v := range vars {
		var elem interface{}

		switch v := v.(type) {
		case bool:
			if v {
				elem = 1
			} else {
				elem = 0
			}
		default:
			elem = v
		}

		avars = append(avars, elem)
	}

	return logger.ExplainSQL(sql, numericPlaceholder, `'`, avars...)
}

func (d Dialector) SavePoint(tx *gorm.DB, name string) error {
	tx.Exec("SAVEPOINT " + name)

	return tx.Error
}

func (d Dialector) RollbackTo(tx *gorm.DB, name string) error {
	tx.Exec("ROLLBACK TO SAVEPOINT " + name)

	return tx.Error
}

func getSchemaIntAndUintType(field *schema.Field) string {
	precision := convertBinaryToDigitPrecision(field.Size)

	if precision == 0 {
		return "NUMBER"
	}

	sqlType := fmt.Sprintf("NUMBER(%d)", precision)

	if field.AutoIncrement {
		sqlType += " GENERATED BY DEFAULT AS IDENTITY"
	}

	return sqlType
}

func getSchemaFloatType(field *schema.Field) string {
	return fmt.Sprintf("FLOAT(%d)", field.Size)
}

func getSchemaStringType(field *schema.Field) string {
	const defaultStringSize = 255

	if field.Size > 4000 {
		return fmt.Sprintf("CLOB")
	}

	size := field.Size

	if size < 1 {
		size = defaultStringSize
	}

	return fmt.Sprintf("VARCHAR2(%d)", size)
}

func convertBinaryToDigitPrecision(binary int) uint {
	// https://www.oracletutorial.com/oracle-basics/oracle-float/
	const binaryToDigitPrecisionFactor = 0.30103

	return uint(math.Ceil(binaryToDigitPrecisionFactor * float64(binary)))
}
